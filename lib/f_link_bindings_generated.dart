// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// Bindings for `src/link/extensions/abl_link/include/abl_link.h`.
///
/// Regenerate bindings with: flutter pub run ffigen --config ffigen.yaml
///
class FLinkBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  FLinkBindings(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  FLinkBindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// ! @brief Construct a new abl_link instance with an initial tempo.
  /// Thread-safe: yes
  /// Realtime-safe: no
  abl_link abl_link_create(
    double bpm,
  ) {
    return _abl_link_create(
      bpm,
    );
  }

  late final _abl_link_createPtr =
      _lookup<ffi.NativeFunction<abl_link Function(ffi.Double)>>(
          'abl_link_create');
  late final _abl_link_create =
      _abl_link_createPtr.asFunction<abl_link Function(double)>();

  /// ! @brief Delete an abl_link instance.
  /// Thread-safe: yes
  /// Realtime-safe: no
  void abl_link_destroy(
    abl_link link,
  ) {
    return _abl_link_destroy(
      link,
    );
  }

  late final _abl_link_destroyPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(abl_link)>>(
          'abl_link_destroy');
  late final _abl_link_destroy =
      _abl_link_destroyPtr.asFunction<void Function(abl_link)>();

  /// ! @brief Is Link currently enabled?
  /// Thread-safe: yes
  /// Realtime-safe: yes
  bool abl_link_is_enabled(
    abl_link link,
  ) {
    return _abl_link_is_enabled(
      link,
    );
  }

  late final _abl_link_is_enabledPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(abl_link)>>(
          'abl_link_is_enabled');
  late final _abl_link_is_enabled =
      _abl_link_is_enabledPtr.asFunction<bool Function(abl_link)>();

  /// ! @brief Enable/disable Link.
  /// Thread-safe: yes
  /// Realtime-safe: no
  void abl_link_enable(
    abl_link link,
    bool enable,
  ) {
    return _abl_link_enable(
      link,
      enable,
    );
  }

  late final _abl_link_enablePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(abl_link, ffi.Bool)>>(
          'abl_link_enable');
  late final _abl_link_enable =
      _abl_link_enablePtr.asFunction<void Function(abl_link, bool)>();

  /// ! @brief: Is start/stop synchronization enabled?
  /// Thread-safe: yes
  /// Realtime-safe: no
  bool abl_link_is_start_stop_sync_enabled(
    abl_link link,
  ) {
    return _abl_link_is_start_stop_sync_enabled(
      link,
    );
  }

  late final _abl_link_is_start_stop_sync_enabledPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(abl_link)>>(
          'abl_link_is_start_stop_sync_enabled');
  late final _abl_link_is_start_stop_sync_enabled =
      _abl_link_is_start_stop_sync_enabledPtr
          .asFunction<bool Function(abl_link)>();

  /// ! @brief: Enable start/stop synchronization.
  /// Thread-safe: yes
  /// Realtime-safe: no
  void abl_link_enable_start_stop_sync(
    abl_link link,
    bool enabled,
  ) {
    return _abl_link_enable_start_stop_sync(
      link,
      enabled,
    );
  }

  late final _abl_link_enable_start_stop_syncPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(abl_link, ffi.Bool)>>(
          'abl_link_enable_start_stop_sync');
  late final _abl_link_enable_start_stop_sync =
      _abl_link_enable_start_stop_syncPtr
          .asFunction<void Function(abl_link, bool)>();

  /// ! @brief How many peers are currently connected in a Link session?
  /// Thread-safe: yes
  /// Realtime-safe: yes
  int abl_link_num_peers(
    abl_link link,
  ) {
    return _abl_link_num_peers(
      link,
    );
  }

  late final _abl_link_num_peersPtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function(abl_link)>>(
          'abl_link_num_peers');
  late final _abl_link_num_peers =
      _abl_link_num_peersPtr.asFunction<int Function(abl_link)>();

  void abl_link_set_num_peers_callback(
    abl_link link,
    abl_link_num_peers_callback callback,
    ffi.Pointer<ffi.Void> context,
  ) {
    return _abl_link_set_num_peers_callback(
      link,
      callback,
      context,
    );
  }

  late final _abl_link_set_num_peers_callbackPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(abl_link, abl_link_num_peers_callback,
              ffi.Pointer<ffi.Void>)>>('abl_link_set_num_peers_callback');
  late final _abl_link_set_num_peers_callback =
      _abl_link_set_num_peers_callbackPtr.asFunction<
          void Function(
              abl_link, abl_link_num_peers_callback, ffi.Pointer<ffi.Void>)>();

  void abl_link_set_tempo_callback(
    abl_link link,
    abl_link_tempo_callback callback,
    ffi.Pointer<ffi.Void> context,
  ) {
    return _abl_link_set_tempo_callback(
      link,
      callback,
      context,
    );
  }

  late final _abl_link_set_tempo_callbackPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(abl_link, abl_link_tempo_callback,
              ffi.Pointer<ffi.Void>)>>('abl_link_set_tempo_callback');
  late final _abl_link_set_tempo_callback =
      _abl_link_set_tempo_callbackPtr.asFunction<
          void Function(
              abl_link, abl_link_tempo_callback, ffi.Pointer<ffi.Void>)>();

  void abl_link_set_start_stop_callback(
    abl_link link,
    abl_link_start_stop_callback callback,
    ffi.Pointer<ffi.Void> context,
  ) {
    return _abl_link_set_start_stop_callback(
      link,
      callback,
      context,
    );
  }

  late final _abl_link_set_start_stop_callbackPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(abl_link, abl_link_start_stop_callback,
              ffi.Pointer<ffi.Void>)>>('abl_link_set_start_stop_callback');
  late final _abl_link_set_start_stop_callback =
      _abl_link_set_start_stop_callbackPtr.asFunction<
          void Function(
              abl_link, abl_link_start_stop_callback, ffi.Pointer<ffi.Void>)>();

  /// ! brief: Get the current link clock time in microseconds.
  /// Thread-safe: yes
  /// Realtime-safe: yes
  int abl_link_clock_micros(
    abl_link link,
  ) {
    return _abl_link_clock_micros(
      link,
    );
  }

  late final _abl_link_clock_microsPtr =
      _lookup<ffi.NativeFunction<ffi.Int64 Function(abl_link)>>(
          'abl_link_clock_micros');
  late final _abl_link_clock_micros =
      _abl_link_clock_microsPtr.asFunction<int Function(abl_link)>();

  /// ! @brief Create a new session_state instance.
  /// Thread-safe: yes
  /// Realtime-safe: no
  ///
  /// @discussion The session_state is to be used with the abl_link_capture... and
  /// abl_link_commit... functions to capture snapshots of the current link state and pass
  /// changes to the link session.
  abl_link_session_state abl_link_create_session_state() {
    return _abl_link_create_session_state();
  }

  late final _abl_link_create_session_statePtr =
      _lookup<ffi.NativeFunction<abl_link_session_state Function()>>(
          'abl_link_create_session_state');
  late final _abl_link_create_session_state = _abl_link_create_session_statePtr
      .asFunction<abl_link_session_state Function()>();

  /// ! @brief Delete a session_state instance.
  /// Thread-safe: yes
  /// Realtime-safe: no
  void abl_link_destroy_session_state(
    abl_link_session_state abl_link_session_state,
  ) {
    return _abl_link_destroy_session_state(
      abl_link_session_state,
    );
  }

  late final _abl_link_destroy_session_statePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(abl_link_session_state)>>(
          'abl_link_destroy_session_state');
  late final _abl_link_destroy_session_state =
      _abl_link_destroy_session_statePtr
          .asFunction<void Function(abl_link_session_state)>();

  /// ! @brief Capture the current Link Session State from the audio thread.
  /// Thread-safe: no
  /// Realtime-safe: yes
  ///
  /// @discussion This function should ONLY be called in the audio thread and must not be
  /// accessed from any other threads. After capturing the session_state holds a snapshot
  /// of the current Link Session State, so it should be used in a local scope. The
  /// session_state should not be created on the audio thread.
  void abl_link_capture_audio_session_state(
    abl_link link,
    abl_link_session_state session_state,
  ) {
    return _abl_link_capture_audio_session_state(
      link,
      session_state,
    );
  }

  late final _abl_link_capture_audio_session_statePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(abl_link, abl_link_session_state)>>(
      'abl_link_capture_audio_session_state');
  late final _abl_link_capture_audio_session_state =
      _abl_link_capture_audio_session_statePtr
          .asFunction<void Function(abl_link, abl_link_session_state)>();

  /// ! @brief Commit the given Session State to the Link session from the
  /// audio thread.
  /// Thread-safe: no
  /// Realtime-safe: yes
  ///
  /// @discussion This function should ONLY be called in the audio thread. The given
  /// session_state will replace the current Link state. Modifications will be
  /// communicated to other peers in the session.
  void abl_link_commit_audio_session_state(
    abl_link link,
    abl_link_session_state session_state,
  ) {
    return _abl_link_commit_audio_session_state(
      link,
      session_state,
    );
  }

  late final _abl_link_commit_audio_session_statePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(abl_link, abl_link_session_state)>>(
      'abl_link_commit_audio_session_state');
  late final _abl_link_commit_audio_session_state =
      _abl_link_commit_audio_session_statePtr
          .asFunction<void Function(abl_link, abl_link_session_state)>();

  /// ! @brief Capture the current Link Session State from an application thread.
  /// Thread-safe: no
  /// Realtime-safe: yes
  ///
  /// @discussion Provides a mechanism for capturing the Link Session State from an
  /// application thread (other than the audio thread). After capturing the session_state
  /// contains a snapshot of the current Link state, so it should be used in a local
  /// scope.
  void abl_link_capture_app_session_state(
    abl_link link,
    abl_link_session_state session_state,
  ) {
    return _abl_link_capture_app_session_state(
      link,
      session_state,
    );
  }

  late final _abl_link_capture_app_session_statePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(abl_link, abl_link_session_state)>>(
      'abl_link_capture_app_session_state');
  late final _abl_link_capture_app_session_state =
      _abl_link_capture_app_session_statePtr
          .asFunction<void Function(abl_link, abl_link_session_state)>();

  /// ! @brief Commit the given Session State to the Link session from an
  /// application thread.
  /// Thread-safe: yes
  /// Realtime-safe: no
  ///
  /// @discussion The given session_state will replace the current Link Session State.
  /// Modifications of the Session State will be communicated to other peers in the
  /// session.
  void abl_link_commit_app_session_state(
    abl_link link,
    abl_link_session_state session_state,
  ) {
    return _abl_link_commit_app_session_state(
      link,
      session_state,
    );
  }

  late final _abl_link_commit_app_session_statePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(abl_link, abl_link_session_state)>>(
      'abl_link_commit_app_session_state');
  late final _abl_link_commit_app_session_state =
      _abl_link_commit_app_session_statePtr
          .asFunction<void Function(abl_link, abl_link_session_state)>();

  /// ! @brief: The tempo of the timeline, in Beats Per Minute.
  ///
  /// @discussion This is a stable value that is appropriate for display to the user. Beat
  /// time progress will not necessarily match this tempo exactly because of clock drift
  /// compensation.
  double abl_link_tempo(
    abl_link_session_state session_state,
  ) {
    return _abl_link_tempo(
      session_state,
    );
  }

  late final _abl_link_tempoPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(abl_link_session_state)>>(
          'abl_link_tempo');
  late final _abl_link_tempo =
      _abl_link_tempoPtr.asFunction<double Function(abl_link_session_state)>();

  /// ! @brief: Set the timeline tempo to the given bpm value, taking effect at the given
  /// time.
  void abl_link_set_tempo(
    abl_link_session_state session_state,
    double bpm,
    int at_time,
  ) {
    return _abl_link_set_tempo(
      session_state,
      bpm,
      at_time,
    );
  }

  late final _abl_link_set_tempoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(abl_link_session_state, ffi.Double,
              ffi.Int64)>>('abl_link_set_tempo');
  late final _abl_link_set_tempo = _abl_link_set_tempoPtr
      .asFunction<void Function(abl_link_session_state, double, int)>();

  /// ! @brief: Get the beat value corresponding to the given time for the given quantum.
  ///
  /// @discussion: The magnitude of the resulting beat value is unique to this Link
  /// client, but its phase with respect to the provided quantum is shared among all
  /// session peers. For non-negative beat values, the following property holds:
  /// fmod(beatAtTime(t, q), q) == phaseAtTime(t, q)
  double abl_link_beat_at_time(
    abl_link_session_state session_state,
    int time,
    double quantum,
  ) {
    return _abl_link_beat_at_time(
      session_state,
      time,
      quantum,
    );
  }

  late final _abl_link_beat_at_timePtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(abl_link_session_state, ffi.Int64,
              ffi.Double)>>('abl_link_beat_at_time');
  late final _abl_link_beat_at_time = _abl_link_beat_at_timePtr
      .asFunction<double Function(abl_link_session_state, int, double)>();

  /// ! @brief: Get the session phase at the given time for the given quantum.
  ///
  /// @discussion: The result is in the interval [0, quantum). The result is equivalent to
  /// fmod(beatAtTime(t, q), q) for non-negative beat values. This function is convenient
  /// if the client application is only interested in the phase and not the beat
  /// magnitude. Also, unlike fmod, it handles negative beat values correctly.
  double abl_link_phase_at_time(
    abl_link_session_state session_state,
    int time,
    double quantum,
  ) {
    return _abl_link_phase_at_time(
      session_state,
      time,
      quantum,
    );
  }

  late final _abl_link_phase_at_timePtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(abl_link_session_state, ffi.Int64,
              ffi.Double)>>('abl_link_phase_at_time');
  late final _abl_link_phase_at_time = _abl_link_phase_at_timePtr
      .asFunction<double Function(abl_link_session_state, int, double)>();

  /// ! @brief: Get the time at which the given beat occurs for the given quantum.
  ///
  /// @discussion: The inverse of beatAtTime, assuming a constant tempo.
  /// beatAtTime(timeAtBeat(b, q), q) === b.
  int abl_link_time_at_beat(
    abl_link_session_state session_state,
    double beat,
    double quantum,
  ) {
    return _abl_link_time_at_beat(
      session_state,
      beat,
      quantum,
    );
  }

  late final _abl_link_time_at_beatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int64 Function(abl_link_session_state, ffi.Double,
              ffi.Double)>>('abl_link_time_at_beat');
  late final _abl_link_time_at_beat = _abl_link_time_at_beatPtr
      .asFunction<int Function(abl_link_session_state, double, double)>();

  /// ! @brief: Attempt to map the given beat to the given time in the context of the given
  /// quantum.
  ///
  /// @discussion: This function behaves differently depending on the state of the
  /// session. If no other peers are connected, then this abl_link instance is in a
  /// session by itself and is free to re-map the beat/time relationship whenever it
  /// pleases. In this case, beatAtTime(time, quantum) == beat after this funtion has been
  /// called.
  ///
  /// If there are other peers in the session, this abl_link instance should not abruptly
  /// re-map the beat/time relationship in the session because that would lead to beat
  /// discontinuities among the other peers. In this case, the given beat will be mapped
  /// to the next time value greater than the given time with the same phase as the given
  /// beat.
  ///
  /// This function is specifically designed to enable the concept of "quantized launch"
  /// in client applications. If there are no other peers in the session, then an event
  /// (such as starting transport) happens immediately when it is requested. If there are
  /// other peers, however, we wait until the next time at which the session phase matches
  /// the phase of the event, thereby executing the event in-phase with the other peers in
  /// the session. The client application only needs to invoke this function to achieve
  /// this behavior and should not need to explicitly check the number of peers.
  void abl_link_request_beat_at_time(
    abl_link_session_state session_state,
    double beat,
    int time,
    double quantum,
  ) {
    return _abl_link_request_beat_at_time(
      session_state,
      beat,
      time,
      quantum,
    );
  }

  late final _abl_link_request_beat_at_timePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(abl_link_session_state, ffi.Double, ffi.Int64,
              ffi.Double)>>('abl_link_request_beat_at_time');
  late final _abl_link_request_beat_at_time = _abl_link_request_beat_at_timePtr
      .asFunction<void Function(abl_link_session_state, double, int, double)>();

  /// ! @brief: Rudely re-map the beat/time relationship for all peers in a session.
  ///
  /// @discussion: DANGER: This function should only be needed in certain special
  /// circumstances. Most applications should not use it. It is very similar to
  /// requestBeatAtTime except that it does not fall back to the quantizing behavior when
  /// it is in a session with other peers. Calling this function will unconditionally map
  /// the given beat to the given time and broadcast the result to the session. This is
  /// very anti-social behavior and should be avoided.
  ///
  /// One of the few legitimate uses of this function is to synchronize a Link session
  /// with an external clock source. By periodically forcing the beat/time mapping
  /// according to an external clock source, a peer can effectively bridge that clock into
  /// a Link session. Much care must be taken at the application layer when implementing
  /// such a feature so that users do not accidentally disrupt Link sessions that they may
  /// join.
  void abl_link_force_beat_at_time(
    abl_link_session_state session_state,
    double beat,
    int time,
    double quantum,
  ) {
    return _abl_link_force_beat_at_time(
      session_state,
      beat,
      time,
      quantum,
    );
  }

  late final _abl_link_force_beat_at_timePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(abl_link_session_state, ffi.Double, ffi.Uint64,
              ffi.Double)>>('abl_link_force_beat_at_time');
  late final _abl_link_force_beat_at_time = _abl_link_force_beat_at_timePtr
      .asFunction<void Function(abl_link_session_state, double, int, double)>();

  /// ! @brief: Set if transport should be playing or stopped, taking effect at the given
  /// time.
  void abl_link_set_is_playing(
    abl_link_session_state session_state,
    bool is_playing,
    int time,
  ) {
    return _abl_link_set_is_playing(
      session_state,
      is_playing,
      time,
    );
  }

  late final _abl_link_set_is_playingPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(abl_link_session_state, ffi.Bool,
              ffi.Uint64)>>('abl_link_set_is_playing');
  late final _abl_link_set_is_playing = _abl_link_set_is_playingPtr
      .asFunction<void Function(abl_link_session_state, bool, int)>();

  /// ! @brief: Is transport playing?
  bool abl_link_is_playing(
    abl_link_session_state session_state,
  ) {
    return _abl_link_is_playing(
      session_state,
    );
  }

  late final _abl_link_is_playingPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(abl_link_session_state)>>(
          'abl_link_is_playing');
  late final _abl_link_is_playing = _abl_link_is_playingPtr
      .asFunction<bool Function(abl_link_session_state)>();

  /// ! @brief: Get the time at which a transport start/stop occurs
  int abl_link_time_for_is_playing(
    abl_link_session_state session_state,
  ) {
    return _abl_link_time_for_is_playing(
      session_state,
    );
  }

  late final _abl_link_time_for_is_playingPtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function(abl_link_session_state)>>(
          'abl_link_time_for_is_playing');
  late final _abl_link_time_for_is_playing = _abl_link_time_for_is_playingPtr
      .asFunction<int Function(abl_link_session_state)>();

  /// ! @brief: Convenience function to attempt to map the given beat to the time
  /// when transport is starting to play in context of the given quantum.
  /// This function evaluates to a no-op if abl_link_is_playing equals false.
  void abl_link_request_beat_at_start_playing_time(
    abl_link_session_state session_state,
    double beat,
    double quantum,
  ) {
    return _abl_link_request_beat_at_start_playing_time(
      session_state,
      beat,
      quantum,
    );
  }

  late final _abl_link_request_beat_at_start_playing_timePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(abl_link_session_state, ffi.Double,
              ffi.Double)>>('abl_link_request_beat_at_start_playing_time');
  late final _abl_link_request_beat_at_start_playing_time =
      _abl_link_request_beat_at_start_playing_timePtr
          .asFunction<void Function(abl_link_session_state, double, double)>();

  /// ! @brief: Convenience function to start or stop transport at a given time and attempt
  /// to map the given beat to this time in context of the given quantum.
  void abl_link_set_is_playing_and_request_beat_at_time(
    abl_link_session_state session_state,
    bool is_playing,
    int time,
    double beat,
    double quantum,
  ) {
    return _abl_link_set_is_playing_and_request_beat_at_time(
      session_state,
      is_playing,
      time,
      beat,
      quantum,
    );
  }

  late final _abl_link_set_is_playing_and_request_beat_at_timePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              abl_link_session_state,
              ffi.Bool,
              ffi.Uint64,
              ffi.Double,
              ffi.Double)>>('abl_link_set_is_playing_and_request_beat_at_time');
  late final _abl_link_set_is_playing_and_request_beat_at_time =
      _abl_link_set_is_playing_and_request_beat_at_timePtr.asFunction<
          void Function(abl_link_session_state, bool, int, double, double)>();

  late final addresses = _SymbolAddresses(this);
}

class _SymbolAddresses {
  final FLinkBindings _library;
  _SymbolAddresses(this._library);
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(abl_link)>>
      get abl_link_destroy => _library._abl_link_destroyPtr;
  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(abl_link_session_state)>>
      get abl_link_destroy_session_state =>
          _library._abl_link_destroy_session_statePtr;
}

/// ! @brief The representation of an abl_link instance
final class abl_link extends ffi.Struct {
  external ffi.Pointer<ffi.Void> impl;
}

/// ! @brief Register a callback to be notified when the number of
/// peers in the Link session changes.
/// Thread-safe: yes
/// Realtime-safe: no
///
/// @discussion The callback is invoked on a Link-managed thread.
typedef abl_link_num_peers_callback = ffi.Pointer<
    ffi.NativeFunction<ffi.Void Function(ffi.Uint64, ffi.Pointer<ffi.Void>)>>;

/// ! @brief Register a callback to be notified when the session
/// tempo changes.
/// Thread-safe: yes
/// Realtime-safe: no
///
/// @discussion The callback is invoked on a Link-managed thread.
typedef abl_link_tempo_callback = ffi.Pointer<
    ffi.NativeFunction<ffi.Void Function(ffi.Double, ffi.Pointer<ffi.Void>)>>;

/// ! brief: Register a callback to be notified when the state of
/// start/stop isPlaying changes.
/// Thread-safe: yes
/// Realtime-safe: no
///
/// @discussion The callback is invoked on a Link-managed thread.
typedef abl_link_start_stop_callback = ffi.Pointer<
    ffi.NativeFunction<ffi.Void Function(ffi.Bool, ffi.Pointer<ffi.Void>)>>;

/// ! @brief The representation of the current local state of a client in a Link Session
///
/// @discussion A session state represents a timeline and the start/stop
/// state. The timeline is a representation of a mapping between time and
/// beats for varying quanta. The start/stop state represents the user
/// intention to start or stop transport at a specific time. Start stop
/// synchronization is an optional feature that allows to share the user
/// request to start or stop transport between a subgroup of peers in a
/// Link session. When observing a change of start/stop state, audio
/// playback of a peer should be started or stopped the same way it would
/// have happened if the user had requested that change at the according
/// time locally. The start/stop state can only be changed by the user.
/// This means that the current local start/stop state persists when
/// joining or leaving a Link session. After joining a Link session
/// start/stop change requests will be communicated to all connected peers.
final class abl_link_session_state extends ffi.Struct {
  external ffi.Pointer<ffi.Void> impl;
}
